<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ARRAY_NOTEMPTY" xml:space="preserve">
    <value>The array must conatin at least one element.</value>
  </data>
  <data name="ENUMERABLE_NOTEMPTY" xml:space="preserve">
    <value>The enumerable has to enumerate at least one element.</value>
  </data>
  <data name="INDEX_UPPERLIMIT" xml:space="preserve">
    <value>The index was greater or equal to the length of the array.</value>
  </data>
  <data name="INTEGER_POSITIVEZERO" xml:space="preserve">
    <value>The value must be a nonnegative integer.</value>
  </data>
  <data name="STRING_NULLEMPTY" xml:space="preserve">
    <value>The value cannot be null or empty.</value>
  </data>
  <data name="STRING_NULLWHITESPACE" xml:space="preserve">
    <value>The value cannot be null or whitespace.</value>
  </data>
  <data name="LIST_NOTEMPTY" xml:space="preserve">
    <value>The list must contain at least one element.</value>
  </data>
  <data name="RANGE_STARTEND_SMALLEREQUALS" xml:space="preserve">
    <value>The start value must be smaller or equal to the end value.</value>
  </data>
  <data name="VALUE_NOTNULL" xml:space="preserve">
    <value>The value cannot be null.</value>
  </data>
  <data name="DICTIONARY_CONCURRENT_NOTSUPPORTED" xml:space="preserve">
    <value>The dictionary can not be a ConcurrentDictionary.</value>
  </data>
  <data name="CULTURE_INVALID" xml:space="preserve">
    <value>Invalid culture name.</value>
  </data>
  <data name="TYPE_NOTGENERIC" xml:space="preserve">
    <value>The type does not have at least one generic type argument.</value>
  </data>
  <data name="COLLECTION_LENGTH_INVALID" xml:space="preserve">
    <value>The number of elements in the collection do not match the expected value.</value>
  </data>
  <data name="FILE_NOTONDEVICE" xml:space="preserve">
    <value>The file specified does not exisit on the device.</value>
  </data>
  <data name="RESOURCESET_CULTURE_EXISTS" xml:space="preserve">
    <value>A resource set with the same culture already exisits.</value>
  </data>
  <data name="RESOURCEREADER_REQUIRE_READTOEND" xml:space="preserve">
    <value>Call ReadToEnd before calling this method.</value>
  </data>
  <data name="RESOURCESET_RESOURCEMISS" xml:space="preserve">
    <value>The key is not present in the dictionary.</value>
  </data>
  <data name="ARRAY_MULTIRANK_NOTSUPPORTED" xml:space="preserve">
    <value>Multirank arrays are not supported.</value>
  </data>
  <data name="ALPHABET_LENGTH_LESS_2" xml:space="preserve">
    <value>The alphabet contains less then two characters.</value>
  </data>
  <data name="ANY_ELEMENT_NULL" xml:space="preserve">
    <value>One or more element is null.</value>
  </data>
  <data name="ARRAY_LOWERBOUND_ZERO" xml:space="preserve">
    <value>The lower bound of the array has to be zero.</value>
  </data>
  <data name="CALL_FROM_CORE_ASSEMBLY_FAILED" xml:space="preserve">
    <value>Cannot be called by the system assembly.</value>
  </data>
  <data name="CLASS_NOT_HAVE_ATTRIBUTE" xml:space="preserve">
    <value>The class does not have the attribute required.</value>
  </data>
  <data name="COLLECTION_INVALID_ELEMENTTYPE" xml:space="preserve">
    <value>Invalid type of elements in the array.</value>
  </data>
  <data name="COLLECTION_NOT_EMPTY" xml:space="preserve">
    <value>The collection cannt be empty.</value>
  </data>
  <data name="COLLECTION_PREDICATE_NO_MATCH_FOUND" xml:space="preserve">
    <value>No match for the predicate was found in the collection.</value>
  </data>
  <data name="CORE_ASSEMBY_NAME_INDETERMINABLE" xml:space="preserve">
    <value>Could not determine the name of the System assembly.</value>
  </data>
  <data name="CTOR_INVOKE_FAILED" xml:space="preserve">
    <value>Invoking the constructor method failed.</value>
  </data>
  <data name="ENUMERATOR_STATE_ABNORMAL" xml:space="preserve">
    <value>The state of the enumerator is abnormal.</value>
  </data>
  <data name="FORMAT_NOT_RECOGNIZED" xml:space="preserve">
    <value>No known format recognized.</value>
  </data>
  <data name="INVALID_DIRECTORY_PATH" xml:space="preserve">
    <value>The path is invalid or does not point to a directory.</value>
  </data>
  <data name="JOBJECT_READER_LOAD_FAILED" xml:space="preserve">
    <value>Failed to load the JObject form the reader.</value>
  </data>
  <data name="KEY_NOTFOUND" xml:space="preserve">
    <value>The key specified was not found.</value>
  </data>
  <data name="METHOD_INVOKE_FAILED" xml:space="preserve">
    <value>Invoking the method failed.</value>
  </data>
  <data name="METHOD_NOT_HAVE_ATTRIBUTE" xml:space="preserve">
    <value>The method does not have the attribute required.</value>
  </data>
  <data name="PROPERTY_NAME_NOTFOUND" xml:space="preserve">
    <value>No property with the name specified was found.</value>
  </data>
  <data name="PROPERTY_READONLY" xml:space="preserve">
    <value>The requested property cannot be set to the specified value.</value>
  </data>
  <data name="RANGE_BOUNDS_NOT_ASSIGNED" xml:space="preserve">
    <value>The bounds of the range must be fully assigned.</value>
  </data>
  <data name="RANGE_TO_GENERIC_ISFROMEND" xml:space="preserve">
    <value>Converting a System.Range to a Range&lt;int&gt; requires Index.IsFromEnd to be false.</value>
  </data>
  <data name="SETTINGS_PROVIDER_ALREADY_REGISTERED" xml:space="preserve">
    <value>A provider with this type of store object is already registered.</value>
  </data>
  <data name="SETTINGS_PROVIDER_NOTFOUND" xml:space="preserve">
    <value>No provider with this type of store object exists.</value>
  </data>
  <data name="TYPE_CANNOT_CONVERT_TO_TYPE" xml:space="preserve">
    <value>Cannot convert to the type specified.</value>
  </data>
  <data name="TYPE_INDETERMINABLE" xml:space="preserve">
    <value>Could not determine the type of the arguments.</value>
  </data>
  <data name="TYPE_ISNOT_ATTRIBUTE" xml:space="preserve">
    <value>The type is no attribute type.</value>
  </data>
  <data name="TYPE_ISNOT_INTERFACE" xml:space="preserve">
    <value>The type specified is no interface</value>
  </data>
  <data name="TYPE_MUST_BE_ENUM" xml:space="preserve">
    <value>The type is required to be an enum.</value>
  </data>
  <data name="TYPE_NOT_IMPLEMENT_GENERIC_IENUMERABLE" xml:space="preserve">
    <value>The type does implement the generic type definition IEnumerable&lt;&gt;.</value>
  </data>
  <data name="VALUE_ONLY_SET_ONCE" xml:space="preserve">
    <value>The value can only be set once.</value>
  </data>
  <data name="UNICODE_ILLEGAL_SYMBOL" xml:space="preserve">
    <value>The string source contains corrupted unicode symbols, at index {0}</value>
  </data>
</root>